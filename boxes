import bpy
import numpy as np
import random
class cubes:
    def __init__(self):
        self.boxes=[]
        self.scene = bpy.data.scenes['Scene']
        self.camera = bpy.data.objects['Camera']
        for i in range(36):
            si=f'{i+1:03d}'
            #print(si)
            r=bpy.data.objects['B.'+si]
            self.boxes.append(r)
    
    def rand(self):
        for b in self.boxes:
            mat=bpy.data.materials.new("Color")
            mat.diffuse_color = (random.random(),random.random(),random.random(), 1)
            b.active_material= mat
            b.location=(random.random()*0.5-0.25, random.random()*0.5-0.25, random.random()*0.5+0.1)
            b.rotation_euler=(random.random()*360, random.random()*360, random.random()*360)
            
    def save_img(self, file_name):
        bpy.context.scene.render.filepath = file_name#os.path.join(self.images_filepath, file_name)
        bpy.ops.render.render(write_still = True)

    def camera_view_bounds_2d(self, mesh_object):
        scene=self.scene
        camera_object=self.camera
        matrix = camera_object.matrix_world.normalized().inverted()
        dg = bpy.context.evaluated_depsgraph_get()
        ob = mesh_object.evaluated_get(dg) #this gives us the evaluated version of the object. Aka with all modifiers and deformations applied.
        mesh = ob.to_mesh()
        #mesh = mesh_object.to_mesh(scene, True, 'RENDER')
        mesh.transform(mesh_object.matrix_world)
        mesh.transform(matrix)
        frame = [-v for v in camera_object.data.view_frame(scene=scene)[:3]]

        lx = []
        ly = []

        for v in mesh.vertices:
            co_local = v.co
            z = -co_local.z

            if z <= 0.0:
                continue
            else:
                frame = [(v / (v.z / z)) for v in frame]

            min_x, max_x = frame[1].x, frame[2].x
            min_y, max_y = frame[0].y, frame[1].y

            x = (co_local.x - min_x) / (max_x - min_x)
            y = (co_local.y - min_y) / (max_y - min_y)

            lx.append(x)
            ly.append(y)
        
        mesh_object.to_mesh_clear()

        if not lx or not ly:
            #print(lx, ly)
            return None

        min_x = np.clip(min(lx), 0.0, 1.0)
        min_y = np.clip(min(ly), 0.0, 1.0)
        max_x = np.clip(max(lx), 0.0, 1.0)
        max_y = np.clip(max(ly), 0.0, 1.0)

        if min_x == max_x or min_y == max_y:
            #print(lx, ly)
            #print(min_x, max_x, min_y, max_y)
            return None

        render = scene.render
        fac = render.resolution_percentage * 0.01
        dim_x = render.resolution_x * fac
        dim_y = render.resolution_y * fac
        
        min_x = int(min_x*640)
        min_y = int(480-min_y*480)
        max_x = int(max_x*640)
        max_y = int(480-max_y*480)
        min_y, max_y = max_y, min_y
        
        
        return (min_x, min_y, max_x, max_y)
    
    def save_txt(self, file_name):
        fn=file_name
        fs=""
        for b in self.boxes:
            xyxy=self.camera_view_bounds_2d(b)
            if xyxy:
                min_x, min_y, max_x, max_y=xyxy
                xc=(min_x+max_x)/(2*640)
                yc=(min_y+max_y)/(2*480)
                yw=(max_x-min_x)/640
                yh=(max_y-min_y)/480                
                
                s=f'0 {xc} {yc} {yw} {yh}\n'
                fs+=s
                
        with open(fn, 'w') as file: file.write(fs)
        #if len(fs): 
            #with open(fn, 'a') as file: file.write(fs)
     
if __name__ == '__main__':
    c=cubes()
    for i in range(10):
        c.rand()
        img_path=f"C:/Users/cfouo/Desktop/dataset/images/img{i}.jpg"
        c.save_img(img_path)
        txt_path=f"C:/Users/cfouo/Desktop/dataset/images/img{i}.txt"
        c.save_txt(txt_path)
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)